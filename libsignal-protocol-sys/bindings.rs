/* automatically generated by rust-bindgen */

pub const RATCHET_CIPHER_KEY_LENGTH: u32 = 32;
pub const RATCHET_MAC_KEY_LENGTH: u32 = 32;
pub const RATCHET_IV_LENGTH: u32 = 16;
pub const CURVE_SIGNATURE_LEN: u32 = 64;
pub const PRE_KEY_MEDIUM_MAX_VALUE: u32 = 16777215;
pub const SG_SUCCESS: u32 = 0;
pub const SG_ERR_NOMEM: i32 = -12;
pub const SG_ERR_INVAL: i32 = -22;
pub const SG_ERR_UNKNOWN: i32 = -1000;
pub const SG_ERR_DUPLICATE_MESSAGE: i32 = -1001;
pub const SG_ERR_INVALID_KEY: i32 = -1002;
pub const SG_ERR_INVALID_KEY_ID: i32 = -1003;
pub const SG_ERR_INVALID_MAC: i32 = -1004;
pub const SG_ERR_INVALID_MESSAGE: i32 = -1005;
pub const SG_ERR_INVALID_VERSION: i32 = -1006;
pub const SG_ERR_LEGACY_MESSAGE: i32 = -1007;
pub const SG_ERR_NO_SESSION: i32 = -1008;
pub const SG_ERR_STALE_KEY_EXCHANGE: i32 = -1009;
pub const SG_ERR_UNTRUSTED_IDENTITY: i32 = -1010;
pub const SG_ERR_VRF_SIG_VERIF_FAILED: i32 = -1011;
pub const SG_ERR_INVALID_PROTO_BUF: i32 = -1100;
pub const SG_ERR_FP_VERSION_MISMATCH: i32 = -1200;
pub const SG_ERR_FP_IDENT_MISMATCH: i32 = -1201;
pub const SG_ERR_MINIMUM: i32 = -9999;
pub const SG_LOG_ERROR: u32 = 0;
pub const SG_LOG_WARNING: u32 = 1;
pub const SG_LOG_NOTICE: u32 = 2;
pub const SG_LOG_INFO: u32 = 3;
pub const SG_LOG_DEBUG: u32 = 4;
pub const SG_CIPHER_AES_CTR_NOPADDING: u32 = 1;
pub const SG_CIPHER_AES_CBC_PKCS5: u32 = 2;
pub const KEY_EXCHANGE_INITIATE_FLAG: u32 = 1;
pub const KEY_EXCHANGE_SIMULTAENOUS_INITIATE_FLAG: u32 = 4;
pub const CIPHERTEXT_UNSUPPORTED_VERSION: u32 = 1;
pub const CIPHERTEXT_CURRENT_VERSION: u32 = 3;
pub const CIPHERTEXT_SIGNAL_TYPE: u32 = 2;
pub const CIPHERTEXT_PREKEY_TYPE: u32 = 3;
pub const CIPHERTEXT_SENDERKEY_TYPE: u32 = 4;
pub const CIPHERTEXT_SENDERKEY_DISTRIBUTION_TYPE: u32 = 5;
pub const CIPHERTEXT_ENCRYPTED_MESSAGE_OVERHEAD: u32 = 53;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct signal_type_base {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct signal_buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct signal_buffer_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct signal_int_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct signal_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct signal_protocol_store_context {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct signal_protocol_address {
    pub name: *const ::std::os::raw::c_char,
    pub name_len: usize,
    pub device_id: i32,
}
#[test]
fn bindgen_test_layout_signal_protocol_address() {
    assert_eq!(
        ::std::mem::size_of::<signal_protocol_address>(),
        24usize,
        concat!("Size of: ", stringify!(signal_protocol_address))
    );
    assert_eq!(
        ::std::mem::align_of::<signal_protocol_address>(),
        8usize,
        concat!("Alignment of ", stringify!(signal_protocol_address))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_address>())).name as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_address),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_address>())).name_len
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_address),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_address>())).device_id
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_address),
            "::",
            stringify!(device_id)
        )
    );
}
#[repr(C)]
pub struct signal_protocol_sender_key_name {
    pub group_id: *const ::std::os::raw::c_char,
    pub group_id_len: usize,
    pub sender: signal_protocol_address,
}
#[test]
fn bindgen_test_layout_signal_protocol_sender_key_name() {
    assert_eq!(
        ::std::mem::size_of::<signal_protocol_sender_key_name>(),
        40usize,
        concat!("Size of: ", stringify!(signal_protocol_sender_key_name))
    );
    assert_eq!(
        ::std::mem::align_of::<signal_protocol_sender_key_name>(),
        8usize,
        concat!("Alignment of ", stringify!(signal_protocol_sender_key_name))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_sender_key_name>())).group_id
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_sender_key_name),
            "::",
            stringify!(group_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_sender_key_name>()))
                .group_id_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_sender_key_name),
            "::",
            stringify!(group_id_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_sender_key_name>())).sender
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_sender_key_name),
            "::",
            stringify!(sender)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_public_key {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_private_key {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_key_pair {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_public_key_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hkdf_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct signal_protocol_key_helper_pre_key_list_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ciphertext_message {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct signal_message {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pre_key_signal_message {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sender_key_message {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sender_key_distribution_message {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ratchet_chain_key {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ratchet_root_key {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ratchet_identity_key_pair {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct ratchet_message_keys {
    pub cipher_key: [u8; 32usize],
    pub mac_key: [u8; 32usize],
    pub iv: [u8; 16usize],
    pub counter: u32,
}
#[test]
fn bindgen_test_layout_ratchet_message_keys() {
    assert_eq!(
        ::std::mem::size_of::<ratchet_message_keys>(),
        84usize,
        concat!("Size of: ", stringify!(ratchet_message_keys))
    );
    assert_eq!(
        ::std::mem::align_of::<ratchet_message_keys>(),
        4usize,
        concat!("Alignment of ", stringify!(ratchet_message_keys))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ratchet_message_keys>())).cipher_key
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ratchet_message_keys),
            "::",
            stringify!(cipher_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ratchet_message_keys>())).mac_key as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ratchet_message_keys),
            "::",
            stringify!(mac_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ratchet_message_keys>())).iv as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ratchet_message_keys),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ratchet_message_keys>())).counter as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ratchet_message_keys),
            "::",
            stringify!(counter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct session_pre_key {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct session_signed_pre_key {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct session_pre_key_bundle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct session_builder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct session_record {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct session_record_state_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct session_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct session_cipher {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sender_message_key {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sender_chain_key {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sender_key_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sender_key_record {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_session_builder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_cipher {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fingerprint {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct displayable_fingerprint {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scannable_fingerprint {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fingerprint_generator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_consistency_signature {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_consistency_commitment {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_consistency_message {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_consistency_signature_list {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ratchet_chain_key_create(
        chain_key: *mut *mut ratchet_chain_key,
        kdf: *mut hkdf_context,
        key: *const u8,
        key_len: usize,
        index: u32,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ratchet_chain_key_get_key(
        chain_key: *const ratchet_chain_key,
        buffer: *mut *mut signal_buffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ratchet_chain_key_get_index(
        chain_key: *const ratchet_chain_key,
    ) -> u32;
}
extern "C" {
    pub fn ratchet_chain_key_get_message_keys(
        chain_key: *mut ratchet_chain_key,
        message_keys: *mut ratchet_message_keys,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ratchet_chain_key_create_next(
        chain_key: *const ratchet_chain_key,
        next_chain_key: *mut *mut ratchet_chain_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ratchet_chain_key_destroy(type_: *mut signal_type_base);
}
extern "C" {
    pub fn ratchet_root_key_create(
        root_key: *mut *mut ratchet_root_key,
        kdf: *mut hkdf_context,
        key: *const u8,
        key_len: usize,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ratchet_root_key_create_chain(
        root_key: *mut ratchet_root_key,
        new_root_key: *mut *mut ratchet_root_key,
        new_chain_key: *mut *mut ratchet_chain_key,
        their_ratchet_key: *mut ec_public_key,
        our_ratchet_key_private: *mut ec_private_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ratchet_root_key_get_key(
        root_key: *mut ratchet_root_key,
        buffer: *mut *mut signal_buffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ratchet_root_key_compare(
        key1: *const ratchet_root_key,
        key2: *const ratchet_root_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ratchet_root_key_destroy(type_: *mut signal_type_base);
}
extern "C" {
    pub fn ratchet_identity_key_pair_create(
        key_pair: *mut *mut ratchet_identity_key_pair,
        public_key: *mut ec_public_key,
        private_key: *mut ec_private_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ratchet_identity_key_pair_serialize(
        buffer: *mut *mut signal_buffer,
        key_pair: *const ratchet_identity_key_pair,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ratchet_identity_key_pair_deserialize(
        key_pair: *mut *mut ratchet_identity_key_pair,
        data: *const u8,
        len: usize,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ratchet_identity_key_pair_get_public(
        key_pair: *const ratchet_identity_key_pair,
    ) -> *mut ec_public_key;
}
extern "C" {
    pub fn ratchet_identity_key_pair_get_private(
        key_pair: *const ratchet_identity_key_pair,
    ) -> *mut ec_private_key;
}
extern "C" {
    pub fn ratchet_identity_key_pair_destroy(type_: *mut signal_type_base);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct symmetric_signal_protocol_parameters {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alice_signal_protocol_parameters {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bob_signal_protocol_parameters {
    _unused: [u8; 0],
}
extern "C" {
    pub fn symmetric_signal_protocol_parameters_create(
        parameters: *mut *mut symmetric_signal_protocol_parameters,
        our_identity_key: *mut ratchet_identity_key_pair,
        our_base_key: *mut ec_key_pair,
        our_ratchet_key: *mut ec_key_pair,
        their_base_key: *mut ec_public_key,
        their_ratchet_key: *mut ec_public_key,
        their_identity_key: *mut ec_public_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symmetric_signal_protocol_parameters_get_our_identity_key(
        parameters: *const symmetric_signal_protocol_parameters,
    ) -> *mut ratchet_identity_key_pair;
}
extern "C" {
    pub fn symmetric_signal_protocol_parameters_get_our_base_key(
        parameters: *const symmetric_signal_protocol_parameters,
    ) -> *mut ec_key_pair;
}
extern "C" {
    pub fn symmetric_signal_protocol_parameters_get_our_ratchet_key(
        parameters: *const symmetric_signal_protocol_parameters,
    ) -> *mut ec_key_pair;
}
extern "C" {
    pub fn symmetric_signal_protocol_parameters_get_their_base_key(
        parameters: *const symmetric_signal_protocol_parameters,
    ) -> *mut ec_public_key;
}
extern "C" {
    pub fn symmetric_signal_protocol_parameters_get_their_ratchet_key(
        parameters: *const symmetric_signal_protocol_parameters,
    ) -> *mut ec_public_key;
}
extern "C" {
    pub fn symmetric_signal_protocol_parameters_get_their_identity_key(
        parameters: *const symmetric_signal_protocol_parameters,
    ) -> *mut ec_public_key;
}
extern "C" {
    pub fn symmetric_signal_protocol_parameters_destroy(
        type_: *mut signal_type_base,
    );
}
extern "C" {
    pub fn alice_signal_protocol_parameters_create(
        parameters: *mut *mut alice_signal_protocol_parameters,
        our_identity_key: *mut ratchet_identity_key_pair,
        our_base_key: *mut ec_key_pair,
        their_identity_key: *mut ec_public_key,
        their_signed_pre_key: *mut ec_public_key,
        their_one_time_pre_key: *mut ec_public_key,
        their_ratchet_key: *mut ec_public_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alice_signal_protocol_parameters_destroy(
        type_: *mut signal_type_base,
    );
}
extern "C" {
    pub fn bob_signal_protocol_parameters_create(
        parameters: *mut *mut bob_signal_protocol_parameters,
        our_identity_key: *mut ratchet_identity_key_pair,
        our_signed_pre_key: *mut ec_key_pair,
        our_one_time_pre_key: *mut ec_key_pair,
        our_ratchet_key: *mut ec_key_pair,
        their_identity_key: *mut ec_public_key,
        their_base_key: *mut ec_public_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bob_signal_protocol_parameters_destroy(type_: *mut signal_type_base);
}
extern "C" {
    pub fn ratcheting_session_symmetric_initialize(
        state: *mut session_state,
        parameters: *mut symmetric_signal_protocol_parameters,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ratcheting_session_alice_initialize(
        state: *mut session_state,
        parameters: *mut alice_signal_protocol_parameters,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ratcheting_session_bob_initialize(
        state: *mut session_state,
        parameters: *mut bob_signal_protocol_parameters,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn curve_internal_fast_tests(
        silent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn curve_decode_point(
        public_key: *mut *mut ec_public_key,
        key_data: *const u8,
        key_len: usize,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ec_public_key_compare(
        key1: *const ec_public_key,
        key2: *const ec_public_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ec_public_key_memcmp(
        key1: *const ec_public_key,
        key2: *const ec_public_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Serialize the public key into a buffer that can be stored.
    /// The format of this data is compatible with the input format of
    /// curve_decode_point().
    ///
    /// @param buffer Pointer to a buffer that will be allocated by this
    /// function
    ///     and filled with the contents of the key. The caller is responsible
    /// for
    ///     freeing this buffer with signal_buffer_free().
    /// @param key Key to serialize
    /// @return 0 on success, negative on failure
    pub fn ec_public_key_serialize(
        buffer: *mut *mut signal_buffer,
        key: *const ec_public_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ec_public_key_destroy(type_: *mut signal_type_base);
}
extern "C" {
    pub fn curve_decode_private_point(
        private_key: *mut *mut ec_private_key,
        key_data: *const u8,
        key_len: usize,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ec_private_key_compare(
        key1: *const ec_private_key,
        key2: *const ec_private_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Serialize the private key into a buffer that can be stored.
    /// The format of this data is compatible with the input format of
    /// curve_decode_private_point().
    ///
    /// @param buffer Pointer to a buffer that will be allocated by this
    /// function
    ///     and filled with the contents of the key. The caller is responsible
    /// for
    ///     freeing this buffer with signal_buffer_free().
    /// @param key Key to serialize
    /// @return 0 on success, negative on failure
    pub fn ec_private_key_serialize(
        buffer: *mut *mut signal_buffer,
        key: *const ec_private_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ec_private_key_destroy(type_: *mut signal_type_base);
}
extern "C" {
    pub fn ec_key_pair_create(
        key_pair: *mut *mut ec_key_pair,
        public_key: *mut ec_public_key,
        private_key: *mut ec_private_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ec_key_pair_get_public(
        key_pair: *const ec_key_pair,
    ) -> *mut ec_public_key;
}
extern "C" {
    pub fn ec_key_pair_get_private(
        key_pair: *const ec_key_pair,
    ) -> *mut ec_private_key;
}
extern "C" {
    pub fn ec_key_pair_destroy(type_: *mut signal_type_base);
}
extern "C" {
    pub fn curve_generate_private_key(
        context: *mut signal_context,
        private_key: *mut *mut ec_private_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn curve_generate_public_key(
        public_key: *mut *mut ec_public_key,
        private_key: *const ec_private_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Generates a Curve25519 keypair.
    ///
    /// @param key_pair Set to a randomly generated Curve25519 keypair on
    /// success.
    /// @return 0 on success, negative on failure
    pub fn curve_generate_key_pair(
        context: *mut signal_context,
        key_pair: *mut *mut ec_key_pair,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Allocate a new ec_public_key list
    ///
    /// @return pointer to the allocated list, or 0 on failure
    pub fn ec_public_key_list_alloc() -> *mut ec_public_key_list;
}
extern "C" {
    /// Copy an ec_public_key list
    ///
    /// @return pointer to the copy of the list, or 0 on failure
    pub fn ec_public_key_list_copy(
        list: *const ec_public_key_list,
    ) -> *mut ec_public_key_list;
}
extern "C" {
    /// Push a new value onto the end of the list
    ///
    /// @param list the list
    /// @param value the value to push
    /// @return 0 on success, negative on failure
    pub fn ec_public_key_list_push_back(
        list: *mut ec_public_key_list,
        value: *mut ec_public_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Gets the size of the list.
    ///
    /// @param list the list
    /// @return the size of the list
    pub fn ec_public_key_list_size(
        list: *const ec_public_key_list,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Gets the value of the element at a particular index in the list
    ///
    /// @param list the list
    /// @param index the index within the list
    /// @return the value
    pub fn ec_public_key_list_at(
        list: *const ec_public_key_list,
        index: ::std::os::raw::c_uint,
    ) -> *mut ec_public_key;
}
extern "C" {
    /// Sorts the list based on a comparison of the key data.
    ///
    /// @param list the list
    pub fn ec_public_key_list_sort(list: *mut ec_public_key_list);
}
extern "C" {
    /// Free the ec_public_key list
    /// @param list the list to free
    pub fn ec_public_key_list_free(list: *mut ec_public_key_list);
}
extern "C" {
    /// Calculates an ECDH agreement.
    ///
    /// @param shared_key_data Set to a 32-byte shared secret on success.
    /// @param public_key The Curve25519 (typically remote party's) public key.
    /// @param private_key The Curve25519 (typically yours) private key.
    /// @return length of the shared secret on success, negative on failure
    pub fn curve_calculate_agreement(
        shared_key_data: *mut *mut u8,
        public_key: *const ec_public_key,
        private_key: *const ec_private_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Verify a Curve25519 signature.
    ///
    /// @param signing_key The Curve25519 public key the signature belongs to.
    /// @param message_data The message that was signed.
    /// @param message_len The length of the message that was signed.
    /// @param signature_data The signature to verify.
    /// @param signature_len The length of the signature to verify.
    /// @return 1 if valid, 0 if invalid, negative on failure
    pub fn curve_verify_signature(
        signing_key: *const ec_public_key,
        message_data: *const u8,
        message_len: usize,
        signature_data: *const u8,
        signature_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Calculates a Curve25519 signature.
    ///
    /// @param signature Set to a 64-byte signature on success.
    /// @param signing_key The private Curve25519 key to create the signature
    /// with.
    /// @param message_data The message to sign.
    /// @param message_len The length of the message to sign.
    /// @return 0 on success, negative on failure
    pub fn curve_calculate_signature(
        context: *mut signal_context,
        signature: *mut *mut signal_buffer,
        signing_key: *const ec_private_key,
        message_data: *const u8,
        message_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Verify a Unique Curve25519 signature.
    ///
    /// @param vrf_output Set to VRF output on success
    /// @param signing_key The Curve25519 public key the unique signature
    /// belongs to.
    /// @param message_data The message that was signed.
    /// @param message_len The length of the message that was signed.
    /// @param signature_data The signature to verify.
    /// @param signature_len The length of the signature to verify.
    /// @return 1 if valid, 0 if invalid, negative on failure
    pub fn curve_verify_vrf_signature(
        context: *mut signal_context,
        vrf_output: *mut *mut signal_buffer,
        signing_key: *const ec_public_key,
        message_data: *const u8,
        message_len: usize,
        signature_data: *const u8,
        signature_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Calculates a Unique Curve25519 signature.
    ///
    /// @param signature Set to a 96-byte signature on success.
    /// @param signing_key The private Curve25519 key to create the signature
    /// with.
    /// @param message_data The message to sign.
    /// @param message_len The length of the message to sign.
    /// @return 0 on success, negative on failure
    pub fn curve_calculate_vrf_signature(
        context: *mut signal_context,
        signature: *mut *mut signal_buffer,
        signing_key: *const ec_private_key,
        message_data: *const u8,
        message_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_record_create(
        record: *mut *mut session_record,
        state: *mut session_state,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_record_serialize(
        buffer: *mut *mut signal_buffer,
        record: *const session_record,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_record_deserialize(
        record: *mut *mut session_record,
        data: *const u8,
        len: usize,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_record_copy(
        record: *mut *mut session_record,
        other_record: *mut session_record,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_record_has_session_state(
        record: *mut session_record,
        version: u32,
        alice_base_key: *const ec_public_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_record_get_state(
        record: *mut session_record,
    ) -> *mut session_state;
}
extern "C" {
    pub fn session_record_set_state(
        record: *mut session_record,
        state: *mut session_state,
    );
}
extern "C" {
    pub fn session_record_get_previous_states_head(
        record: *const session_record,
    ) -> *mut session_record_state_node;
}
extern "C" {
    pub fn session_record_get_previous_states_element(
        node: *const session_record_state_node,
    ) -> *mut session_state;
}
extern "C" {
    pub fn session_record_get_previous_states_next(
        node: *const session_record_state_node,
    ) -> *mut session_record_state_node;
}
extern "C" {
    /// Removes the specified node in the previous states list.
    /// @param node the node to remove
    /// @return the node immediately following the removed node, or null if at
    /// the end of the list
    pub fn session_record_get_previous_states_remove(
        record: *mut session_record,
        node: *mut session_record_state_node,
    ) -> *mut session_record_state_node;
}
extern "C" {
    pub fn session_record_is_fresh(
        record: *mut session_record,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Move the current session_state into the list of "previous" session
    /// states,
    /// and replace the current session_state with a fresh reset instance.
    ///
    /// @return 0 on success, negative on failure
    pub fn session_record_archive_current_state(
        record: *mut session_record,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_record_promote_state(
        record: *mut session_record,
        promoted_state: *mut session_state,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_record_get_user_record(
        record: *const session_record,
    ) -> *mut signal_buffer;
}
extern "C" {
    pub fn session_record_set_user_record(
        record: *mut session_record,
        user_record: *mut signal_buffer,
    );
}
extern "C" {
    pub fn session_record_destroy(type_: *mut signal_type_base);
}
extern "C" {
    pub fn session_pre_key_create(
        pre_key: *mut *mut session_pre_key,
        id: u32,
        key_pair: *mut ec_key_pair,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_pre_key_serialize(
        buffer: *mut *mut signal_buffer,
        pre_key: *const session_pre_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_pre_key_deserialize(
        pre_key: *mut *mut session_pre_key,
        data: *const u8,
        len: usize,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_pre_key_get_id(pre_key: *const session_pre_key) -> u32;
}
extern "C" {
    pub fn session_pre_key_get_key_pair(
        pre_key: *const session_pre_key,
    ) -> *mut ec_key_pair;
}
extern "C" {
    pub fn session_pre_key_destroy(type_: *mut signal_type_base);
}
extern "C" {
    pub fn session_signed_pre_key_create(
        pre_key: *mut *mut session_signed_pre_key,
        id: u32,
        timestamp: u64,
        key_pair: *mut ec_key_pair,
        signature: *const u8,
        signature_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_signed_pre_key_serialize(
        buffer: *mut *mut signal_buffer,
        pre_key: *const session_signed_pre_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_signed_pre_key_deserialize(
        pre_key: *mut *mut session_signed_pre_key,
        data: *const u8,
        len: usize,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_signed_pre_key_get_id(
        pre_key: *const session_signed_pre_key,
    ) -> u32;
}
extern "C" {
    pub fn session_signed_pre_key_get_timestamp(
        pre_key: *const session_signed_pre_key,
    ) -> u64;
}
extern "C" {
    pub fn session_signed_pre_key_get_key_pair(
        pre_key: *const session_signed_pre_key,
    ) -> *mut ec_key_pair;
}
extern "C" {
    pub fn session_signed_pre_key_get_signature(
        pre_key: *const session_signed_pre_key,
    ) -> *const u8;
}
extern "C" {
    pub fn session_signed_pre_key_get_signature_len(
        pre_key: *const session_signed_pre_key,
    ) -> usize;
}
extern "C" {
    pub fn session_signed_pre_key_destroy(type_: *mut signal_type_base);
}
extern "C" {
    pub fn session_pre_key_bundle_create(
        bundle: *mut *mut session_pre_key_bundle,
        registration_id: u32,
        device_id: ::std::os::raw::c_int,
        pre_key_id: u32,
        pre_key_public: *mut ec_public_key,
        signed_pre_key_id: u32,
        signed_pre_key_public: *mut ec_public_key,
        signed_pre_key_signature_data: *const u8,
        signed_pre_key_signature_len: usize,
        identity_key: *mut ec_public_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_pre_key_bundle_get_registration_id(
        bundle: *const session_pre_key_bundle,
    ) -> u32;
}
extern "C" {
    pub fn session_pre_key_bundle_get_device_id(
        bundle: *const session_pre_key_bundle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_pre_key_bundle_get_pre_key_id(
        bundle: *const session_pre_key_bundle,
    ) -> u32;
}
extern "C" {
    pub fn session_pre_key_bundle_get_pre_key(
        bundle: *const session_pre_key_bundle,
    ) -> *mut ec_public_key;
}
extern "C" {
    pub fn session_pre_key_bundle_get_signed_pre_key_id(
        bundle: *const session_pre_key_bundle,
    ) -> u32;
}
extern "C" {
    pub fn session_pre_key_bundle_get_signed_pre_key(
        bundle: *const session_pre_key_bundle,
    ) -> *mut ec_public_key;
}
extern "C" {
    pub fn session_pre_key_bundle_get_signed_pre_key_signature(
        bundle: *const session_pre_key_bundle,
    ) -> *mut signal_buffer;
}
extern "C" {
    pub fn session_pre_key_bundle_get_identity_key(
        bundle: *const session_pre_key_bundle,
    ) -> *mut ec_public_key;
}
extern "C" {
    pub fn session_pre_key_bundle_destroy(type_: *mut signal_type_base);
}
extern "C" {
    pub fn sender_key_record_create(
        record: *mut *mut sender_key_record,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_key_record_serialize(
        buffer: *mut *mut signal_buffer,
        record: *mut sender_key_record,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_key_record_deserialize(
        record: *mut *mut sender_key_record,
        data: *const u8,
        len: usize,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_key_record_copy(
        record: *mut *mut sender_key_record,
        other_state: *mut sender_key_record,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_key_record_is_empty(
        record: *mut sender_key_record,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_key_record_get_sender_key_state(
        record: *mut sender_key_record,
        state: *mut *mut sender_key_state,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_key_record_get_sender_key_state_by_id(
        record: *mut sender_key_record,
        state: *mut *mut sender_key_state,
        key_id: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_key_record_add_sender_key_state(
        record: *mut sender_key_record,
        id: u32,
        iteration: u32,
        chain_key: *mut signal_buffer,
        signature_key: *mut ec_public_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_key_record_set_sender_key_state(
        record: *mut sender_key_record,
        id: u32,
        iteration: u32,
        chain_key: *mut signal_buffer,
        signature_key_pair: *mut ec_key_pair,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_key_record_get_user_record(
        record: *const sender_key_record,
    ) -> *mut signal_buffer;
}
extern "C" {
    pub fn sender_key_record_set_user_record(
        record: *mut sender_key_record,
        user_record: *mut signal_buffer,
    );
}
extern "C" {
    pub fn sender_key_record_destroy(type_: *mut signal_type_base);
}
extern "C" {
    pub fn signal_type_ref(instance: *mut signal_type_base);
}
extern "C" {
    pub fn signal_type_unref(instance: *mut signal_type_base);
}
extern "C" {
    /// Allocate a new buffer to store data of the provided length.
    ///
    /// @param len length of the buffer to allocate
    /// @return pointer to the allocated buffer, or 0 on failure
    pub fn signal_buffer_alloc(len: usize) -> *mut signal_buffer;
}
extern "C" {
    /// Create a new buffer and copy the provided data into it.
    ///
    /// @param data pointer to the start of the data
    /// @param len length of the data
    /// @return pointer to the allocated buffer, or 0 on failure
    pub fn signal_buffer_create(
        data: *const u8,
        len: usize,
    ) -> *mut signal_buffer;
}
extern "C" {
    /// Create a copy of an existing buffer.
    ///
    /// @param buffer the existing buffer to copy
    /// @return pointer to the updated buffer, or 0 on failure
    pub fn signal_buffer_copy(
        buffer: *const signal_buffer,
    ) -> *mut signal_buffer;
}
extern "C" {
    /// Create a copy of an existing buffer.
    ///
    /// @param buffer the existing buffer to copy
    /// @param n the maximum number of bytes to copy
    /// @return pointer to the updated buffer, or 0 on failure
    pub fn signal_buffer_n_copy(
        buffer: *const signal_buffer,
        n: usize,
    ) -> *mut signal_buffer;
}
extern "C" {
    /// Append the provided data to an existing buffer.
    /// Note: The underlying buffer is only expanded by an amount sufficient
    /// to hold the data being appended. There is no additional reserved space
    /// to reduce the need for memory allocations.
    ///
    /// @param buffer the existing buffer to append to
    /// @param data pointer to the start of the data
    /// @param len length of the data
    /// @return pointer to the updated buffer, or 0 on failure
    pub fn signal_buffer_append(
        buffer: *mut signal_buffer,
        data: *const u8,
        len: usize,
    ) -> *mut signal_buffer;
}
extern "C" {
    /// Gets the data pointer for the buffer.
    /// This can be used to read and write data stored in the buffer.
    ///
    /// @param buffer pointer to the buffer instance
    /// @return data pointer
    pub fn signal_buffer_data(buffer: *mut signal_buffer) -> *mut u8;
}
extern "C" {
    /// Gets the data pointer for the buffer.
    /// This can be used to read and write data stored in the buffer.
    ///
    /// @param buffer pointer to the buffer instance
    /// @return data pointer
    pub fn signal_buffer_const_data(buffer: *const signal_buffer) -> *const u8;
}
extern "C" {
    /// Gets the length of the data stored within the buffer.
    ///
    /// @param buffer pointer to the buffer instance
    /// @return data length
    pub fn signal_buffer_len(buffer: *const signal_buffer) -> usize;
}
extern "C" {
    /// Compare two buffers.
    ///
    /// @param buffer1 first buffer to compare
    /// @param buffer2 second buffer to compare
    /// @return 0 if the two buffers are equal, negative or positive otherwise
    pub fn signal_buffer_compare(
        buffer1: *mut signal_buffer,
        buffer2: *mut signal_buffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Free the data buffer.
    ///
    /// @param buffer pointer to the buffer instance to free
    pub fn signal_buffer_free(buffer: *mut signal_buffer);
}
extern "C" {
    /// Zero and free the data buffer.
    /// This function should be used when the buffer contains sensitive
    /// data, to make sure the memory is cleared before being freed.
    ///
    /// @param buffer pointer to the buffer instance to free
    pub fn signal_buffer_bzero_free(buffer: *mut signal_buffer);
}
extern "C" {
    /// Allocate a new buffer list.
    ///
    /// @return pointer to the allocated buffer, or 0 on failure
    pub fn signal_buffer_list_alloc() -> *mut signal_buffer_list;
}
extern "C" {
    /// Create a copy of an existing buffer list.
    ///
    /// @param list the existing buffer list to copy
    /// @return pointer to the updated buffer, or 0 on failure
    pub fn signal_buffer_list_copy(
        list: *const signal_buffer_list,
    ) -> *mut signal_buffer_list;
}
extern "C" {
    /// Push the provided buffer onto the end of the list.
    /// The list will take ownership of the buffer, and free it when the list is
    /// freed.
    ///
    /// @param list the buffer list
    /// @param buffer the buffer to push
    /// @return 0 on success, or negative on failure
    pub fn signal_buffer_list_push_back(
        list: *mut signal_buffer_list,
        buffer: *mut signal_buffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Gets the size of the buffer list.
    ///
    /// @param list the buffer list
    /// @return the size of the list
    pub fn signal_buffer_list_size(
        list: *mut signal_buffer_list,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Gets the value of the element at a particular index in the list
    ///
    /// @param list the list
    /// @param index the index within the list
    /// @return the value
    pub fn signal_buffer_list_at(
        list: *mut signal_buffer_list,
        index: ::std::os::raw::c_uint,
    ) -> *mut signal_buffer;
}
extern "C" {
    /// Free the buffer list, including all the buffers added to it.
    ///
    /// @param list the buffer list
    pub fn signal_buffer_list_free(list: *mut signal_buffer_list);
}
extern "C" {
    /// Free the buffer list, including all the buffers added to it.
    /// This function should be used when the buffer list contains sensitive
    /// data, to make sure the memory is cleared before being freed.
    ///
    /// @param list the buffer list
    pub fn signal_buffer_list_bzero_free(list: *mut signal_buffer_list);
}
extern "C" {
    /// Allocate a new int list
    ///
    /// @return pointer to the allocated buffer, or 0 on failure
    pub fn signal_int_list_alloc() -> *mut signal_int_list;
}
extern "C" {
    /// Push a new value onto the end of the list
    ///
    /// @param list the list
    /// @param value the value to push
    /// @return 0 on success, or negative on failure
    pub fn signal_int_list_push_back(
        list: *mut signal_int_list,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Gets the size of the list.
    ///
    /// @param list the list
    /// @return the size of the list
    pub fn signal_int_list_size(
        list: *mut signal_int_list,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Gets the value of the element at a particular index in the list
    ///
    /// @param list the list
    /// @param index the index within the list
    /// @return the value
    pub fn signal_int_list_at(
        list: *mut signal_int_list,
        index: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Free the int list
    /// @param list the list to free
    pub fn signal_int_list_free(list: *mut signal_int_list);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct signal_crypto_provider {
    /// Callback for a secure random number generator.
    /// This function shall fill the provided buffer with random bytes.
    ///
    /// @param data pointer to the output buffer
    /// @param len size of the output buffer
    /// @return 0 on success, negative on failure
    pub random_func: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut u8,
            len: usize,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Callback for an HMAC-SHA256 implementation.
    /// This function shall initialize an HMAC context with the provided key.
    ///
    /// @param hmac_context private HMAC context pointer
    /// @param key pointer to the key
    /// @param key_len length of the key
    /// @return 0 on success, negative on failure
    pub hmac_sha256_init_func: ::std::option::Option<
        unsafe extern "C" fn(
            hmac_context: *mut *mut ::std::os::raw::c_void,
            key: *const u8,
            key_len: usize,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Callback for an HMAC-SHA256 implementation.
    /// This function shall update the HMAC context with the provided data
    ///
    /// @param hmac_context private HMAC context pointer
    /// @param data pointer to the data
    /// @param data_len length of the data
    /// @return 0 on success, negative on failure
    pub hmac_sha256_update_func: ::std::option::Option<
        unsafe extern "C" fn(
            hmac_context: *mut ::std::os::raw::c_void,
            data: *const u8,
            data_len: usize,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Callback for an HMAC-SHA256 implementation.
    /// This function shall finalize an HMAC calculation and populate the
    /// output
    /// buffer with the result.
    ///
    /// @param hmac_context private HMAC context pointer
    /// @param output buffer to be allocated and populated with the result
    /// @return 0 on success, negative on failure
    pub hmac_sha256_final_func: ::std::option::Option<
        unsafe extern "C" fn(
            hmac_context: *mut ::std::os::raw::c_void,
            output: *mut *mut signal_buffer,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Callback for an HMAC-SHA256 implementation.
    /// This function shall free the private context allocated in
    /// hmac_sha256_init_func.
    ///
    /// @param hmac_context private HMAC context pointer
    pub hmac_sha256_cleanup_func: ::std::option::Option<
        unsafe extern "C" fn(
            hmac_context: *mut ::std::os::raw::c_void,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    /// Callback for a SHA512 message digest implementation.
    /// This function shall initialize a digest context.
    ///
    /// @param digest_context private digest context pointer
    /// @return 0 on success, negative on failure
    pub sha512_digest_init_func: ::std::option::Option<
        unsafe extern "C" fn(
            digest_context: *mut *mut ::std::os::raw::c_void,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Callback for a SHA512 message digest implementation.
    /// This function shall update the digest context with the provided data.
    ///
    /// @param digest_context private digest context pointer
    /// @param data pointer to the data
    /// @param data_len length of the data
    /// @return 0 on success, negative on failure
    pub sha512_digest_update_func: ::std::option::Option<
        unsafe extern "C" fn(
            digest_context: *mut ::std::os::raw::c_void,
            data: *const u8,
            data_len: usize,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Callback for a SHA512 message digest implementation.
    /// This function shall finalize the digest calculation, populate the
    /// output buffer with the result, and prepare the context for reuse.
    ///
    /// @param digest_context private digest context pointer
    /// @param output buffer to be allocated and populated with the result
    /// @return 0 on success, negative on failure
    pub sha512_digest_final_func: ::std::option::Option<
        unsafe extern "C" fn(
            digest_context: *mut ::std::os::raw::c_void,
            output: *mut *mut signal_buffer,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Callback for a SHA512 message digest implementation.
    /// This function shall free the private context allocated in
    /// sha512_digest_init_func.
    ///
    /// @param digest_context private digest context pointer
    pub sha512_digest_cleanup_func: ::std::option::Option<
        unsafe extern "C" fn(
            digest_context: *mut ::std::os::raw::c_void,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    /// Callback for an AES encryption implementation.
    ///
    /// @param output buffer to be allocated and populated with the ciphertext
    /// @param cipher specific cipher variant to use, either
    /// SG_CIPHER_AES_CTR_NOPADDING or SG_CIPHER_AES_CBC_PKCS5
    /// @param key the encryption key
    /// @param key_len length of the encryption key
    /// @param iv the initialization vector
    /// @param iv_len length of the initialization vector
    /// @param plaintext the plaintext to encrypt
    /// @param plaintext_len length of the plaintext
    /// @return 0 on success, negative on failure
    pub encrypt_func: ::std::option::Option<
        unsafe extern "C" fn(
            output: *mut *mut signal_buffer,
            cipher: ::std::os::raw::c_int,
            key: *const u8,
            key_len: usize,
            iv: *const u8,
            iv_len: usize,
            plaintext: *const u8,
            plaintext_len: usize,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Callback for an AES decryption implementation.
    ///
    /// @param output buffer to be allocated and populated with the plaintext
    /// @param cipher specific cipher variant to use, either
    /// SG_CIPHER_AES_CTR_NOPADDING or SG_CIPHER_AES_CBC_PKCS5
    /// @param key the encryption key
    /// @param key_len length of the encryption key
    /// @param iv the initialization vector
    /// @param iv_len length of the initialization vector
    /// @param ciphertext the ciphertext to decrypt
    /// @param ciphertext_len length of the ciphertext
    /// @return 0 on success, negative on failure
    pub decrypt_func: ::std::option::Option<
        unsafe extern "C" fn(
            output: *mut *mut signal_buffer,
            cipher: ::std::os::raw::c_int,
            key: *const u8,
            key_len: usize,
            iv: *const u8,
            iv_len: usize,
            ciphertext: *const u8,
            ciphertext_len: usize,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// User data pointer
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_signal_crypto_provider() {
    assert_eq!(
        ::std::mem::size_of::<signal_crypto_provider>(),
        96usize,
        concat!("Size of: ", stringify!(signal_crypto_provider))
    );
    assert_eq!(
        ::std::mem::align_of::<signal_crypto_provider>(),
        8usize,
        concat!("Alignment of ", stringify!(signal_crypto_provider))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_crypto_provider>())).random_func
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_crypto_provider),
            "::",
            stringify!(random_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_crypto_provider>()))
                .hmac_sha256_init_func as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_crypto_provider),
            "::",
            stringify!(hmac_sha256_init_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_crypto_provider>()))
                .hmac_sha256_update_func as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_crypto_provider),
            "::",
            stringify!(hmac_sha256_update_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_crypto_provider>()))
                .hmac_sha256_final_func as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_crypto_provider),
            "::",
            stringify!(hmac_sha256_final_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_crypto_provider>()))
                .hmac_sha256_cleanup_func as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_crypto_provider),
            "::",
            stringify!(hmac_sha256_cleanup_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_crypto_provider>()))
                .sha512_digest_init_func as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_crypto_provider),
            "::",
            stringify!(sha512_digest_init_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_crypto_provider>()))
                .sha512_digest_update_func as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_crypto_provider),
            "::",
            stringify!(sha512_digest_update_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_crypto_provider>()))
                .sha512_digest_final_func as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_crypto_provider),
            "::",
            stringify!(sha512_digest_final_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_crypto_provider>()))
                .sha512_digest_cleanup_func as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_crypto_provider),
            "::",
            stringify!(sha512_digest_cleanup_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_crypto_provider>())).encrypt_func
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_crypto_provider),
            "::",
            stringify!(encrypt_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_crypto_provider>())).decrypt_func
                as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_crypto_provider),
            "::",
            stringify!(decrypt_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_crypto_provider>())).user_data
                as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_crypto_provider),
            "::",
            stringify!(user_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct signal_protocol_session_store {
    /// Returns a copy of the serialized session record corresponding to the
    /// provided recipient ID + device ID tuple.
    ///
    /// @param record pointer to a freshly allocated buffer containing the
    ///     serialized session record. Unset if no record was found.
    ///     The Signal Protocol library is responsible for freeing this buffer.
    /// @param user_record pointer to a freshly allocated buffer containing
    ///     application specific data stored alongside the serialized session
    ///     record. If no such data exists, then this pointer may be left
    /// unset.
    ///     The Signal Protocol library is responsible for freeing this buffer.
    /// @param address the address of the remote client
    /// @return 1 if the session was loaded, 0 if the session was not found,
    /// negative on failure
    pub load_session_func: ::std::option::Option<
        unsafe extern "C" fn(
            record: *mut *mut signal_buffer,
            user_record: *mut *mut signal_buffer,
            address: *const signal_protocol_address,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Returns all known devices with active sessions for a recipient
    ///
    /// @param pointer to an array that will be allocated and populated with
    /// the result
    /// @param name the name of the remote client
    /// @param name_len the length of the name
    /// @return size of the sessions array, or negative on failure
    pub get_sub_device_sessions_func: ::std::option::Option<
        unsafe extern "C" fn(
            sessions: *mut *mut signal_int_list,
            name: *const ::std::os::raw::c_char,
            name_len: usize,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Commit to storage the session record for a given
    /// recipient ID + device ID tuple.
    ///
    /// @param address the address of the remote client
    /// @param record pointer to a buffer containing the serialized session
    ///     record for the remote client
    /// @param record_len length of the serialized session record
    /// @param user_record pointer to a buffer containing application specific
    ///     data to be stored alongside the serialized session record for the
    ///     remote client. If no such data exists, then this pointer will be
    /// null.
    /// @param user_record_len length of the application specific data
    /// @return 0 on success, negative on failure
    pub store_session_func: ::std::option::Option<
        unsafe extern "C" fn(
            address: *const signal_protocol_address,
            record: *mut u8,
            record_len: usize,
            user_record: *mut u8,
            user_record_len: usize,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Determine whether there is a committed session record for a
    /// recipient ID + device ID tuple.
    ///
    /// @param address the address of the remote client
    /// @return 1 if a session record exists, 0 otherwise.
    pub contains_session_func: ::std::option::Option<
        unsafe extern "C" fn(
            address: *const signal_protocol_address,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Remove a session record for a recipient ID + device ID tuple.
    ///
    /// @param address the address of the remote client
    /// @return 1 if a session was deleted, 0 if a session was not deleted,
    /// negative on error
    pub delete_session_func: ::std::option::Option<
        unsafe extern "C" fn(
            address: *const signal_protocol_address,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Remove the session records corresponding to all devices of a recipient
    /// ID.
    ///
    /// @param name the name of the remote client
    /// @param name_len the length of the name
    /// @return the number of deleted sessions on success, negative on failure
    pub delete_all_sessions_func: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            name_len: usize,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Function called to perform cleanup when the data store context is being
    /// destroyed.
    pub destroy_func: ::std::option::Option<
        unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void),
    >,
    /// User data pointer
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_signal_protocol_session_store() {
    assert_eq!(
        ::std::mem::size_of::<signal_protocol_session_store>(),
        64usize,
        concat!("Size of: ", stringify!(signal_protocol_session_store))
    );
    assert_eq!(
        ::std::mem::align_of::<signal_protocol_session_store>(),
        8usize,
        concat!("Alignment of ", stringify!(signal_protocol_session_store))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_session_store>()))
                .load_session_func as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_session_store),
            "::",
            stringify!(load_session_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_session_store>()))
                .get_sub_device_sessions_func as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_session_store),
            "::",
            stringify!(get_sub_device_sessions_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_session_store>()))
                .store_session_func as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_session_store),
            "::",
            stringify!(store_session_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_session_store>()))
                .contains_session_func as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_session_store),
            "::",
            stringify!(contains_session_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_session_store>()))
                .delete_session_func as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_session_store),
            "::",
            stringify!(delete_session_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_session_store>()))
                .delete_all_sessions_func as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_session_store),
            "::",
            stringify!(delete_all_sessions_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_session_store>()))
                .destroy_func as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_session_store),
            "::",
            stringify!(destroy_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_session_store>())).user_data
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_session_store),
            "::",
            stringify!(user_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct signal_protocol_pre_key_store {
    /// Load a local serialized PreKey record.
    ///
    /// @param record pointer to a newly allocated buffer containing the
    /// record,
    ///     if found. Unset if no record was found.
    ///     The Signal Protocol library is responsible for freeing this buffer.
    /// @param pre_key_id the ID of the local serialized PreKey record
    /// @retval SG_SUCCESS if the key was found
    /// @retval SG_ERR_INVALID_KEY_ID if the key could not be found
    pub load_pre_key: ::std::option::Option<
        unsafe extern "C" fn(
            record: *mut *mut signal_buffer,
            pre_key_id: u32,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Store a local serialized PreKey record.
    ///
    /// @param pre_key_id the ID of the PreKey record to store.
    /// @param record pointer to a buffer containing the serialized record
    /// @param record_len length of the serialized record
    /// @return 0 on success, negative on failure
    pub store_pre_key: ::std::option::Option<
        unsafe extern "C" fn(
            pre_key_id: u32,
            record: *mut u8,
            record_len: usize,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Determine whether there is a committed PreKey record matching the
    /// provided ID.
    ///
    /// @param pre_key_id A PreKey record ID.
    /// @return 1 if the store has a record for the PreKey ID, 0 otherwise
    pub contains_pre_key: ::std::option::Option<
        unsafe extern "C" fn(
            pre_key_id: u32,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Delete a PreKey record from local storage.
    ///
    /// @param pre_key_id The ID of the PreKey record to remove.
    /// @return 0 on success, negative on failure
    pub remove_pre_key: ::std::option::Option<
        unsafe extern "C" fn(
            pre_key_id: u32,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Function called to perform cleanup when the data store context is being
    /// destroyed.
    pub destroy_func: ::std::option::Option<
        unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void),
    >,
    /// User data pointer
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_signal_protocol_pre_key_store() {
    assert_eq!(
        ::std::mem::size_of::<signal_protocol_pre_key_store>(),
        48usize,
        concat!("Size of: ", stringify!(signal_protocol_pre_key_store))
    );
    assert_eq!(
        ::std::mem::align_of::<signal_protocol_pre_key_store>(),
        8usize,
        concat!("Alignment of ", stringify!(signal_protocol_pre_key_store))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_pre_key_store>()))
                .load_pre_key as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_pre_key_store),
            "::",
            stringify!(load_pre_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_pre_key_store>()))
                .store_pre_key as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_pre_key_store),
            "::",
            stringify!(store_pre_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_pre_key_store>()))
                .contains_pre_key as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_pre_key_store),
            "::",
            stringify!(contains_pre_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_pre_key_store>()))
                .remove_pre_key as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_pre_key_store),
            "::",
            stringify!(remove_pre_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_pre_key_store>()))
                .destroy_func as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_pre_key_store),
            "::",
            stringify!(destroy_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_pre_key_store>())).user_data
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_pre_key_store),
            "::",
            stringify!(user_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct signal_protocol_signed_pre_key_store {
    /// Load a local serialized signed PreKey record.
    ///
    /// @param record pointer to a newly allocated buffer containing the
    /// record,
    ///     if found. Unset if no record was found.
    ///     The Signal Protocol library is responsible for freeing this buffer.
    /// @param signed_pre_key_id the ID of the local signed PreKey record
    /// @retval SG_SUCCESS if the key was found
    /// @retval SG_ERR_INVALID_KEY_ID if the key could not be found
    pub load_signed_pre_key: ::std::option::Option<
        unsafe extern "C" fn(
            record: *mut *mut signal_buffer,
            signed_pre_key_id: u32,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Store a local serialized signed PreKey record.
    ///
    /// @param signed_pre_key_id the ID of the signed PreKey record to store
    /// @param record pointer to a buffer containing the serialized record
    /// @param record_len length of the serialized record
    /// @return 0 on success, negative on failure
    pub store_signed_pre_key: ::std::option::Option<
        unsafe extern "C" fn(
            signed_pre_key_id: u32,
            record: *mut u8,
            record_len: usize,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Determine whether there is a committed signed PreKey record matching
    /// the provided ID.
    ///
    /// @param signed_pre_key_id A signed PreKey record ID.
    /// @return 1 if the store has a record for the signed PreKey ID, 0
    /// otherwise
    pub contains_signed_pre_key: ::std::option::Option<
        unsafe extern "C" fn(
            signed_pre_key_id: u32,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Delete a SignedPreKeyRecord from local storage.
    ///
    /// @param signed_pre_key_id The ID of the signed PreKey record to remove.
    /// @return 0 on success, negative on failure
    pub remove_signed_pre_key: ::std::option::Option<
        unsafe extern "C" fn(
            signed_pre_key_id: u32,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Function called to perform cleanup when the data store context is being
    /// destroyed.
    pub destroy_func: ::std::option::Option<
        unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void),
    >,
    /// User data pointer
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_signal_protocol_signed_pre_key_store() {
    assert_eq!(
        ::std::mem::size_of::<signal_protocol_signed_pre_key_store>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(signal_protocol_signed_pre_key_store)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<signal_protocol_signed_pre_key_store>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(signal_protocol_signed_pre_key_store)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_signed_pre_key_store>()))
                .load_signed_pre_key as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_signed_pre_key_store),
            "::",
            stringify!(load_signed_pre_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_signed_pre_key_store>()))
                .store_signed_pre_key as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_signed_pre_key_store),
            "::",
            stringify!(store_signed_pre_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_signed_pre_key_store>()))
                .contains_signed_pre_key as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_signed_pre_key_store),
            "::",
            stringify!(contains_signed_pre_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_signed_pre_key_store>()))
                .remove_signed_pre_key as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_signed_pre_key_store),
            "::",
            stringify!(remove_signed_pre_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_signed_pre_key_store>()))
                .destroy_func as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_signed_pre_key_store),
            "::",
            stringify!(destroy_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_signed_pre_key_store>()))
                .user_data as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_signed_pre_key_store),
            "::",
            stringify!(user_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct signal_protocol_identity_key_store {
    /// Get the local client's identity key pair.
    ///
    /// @param public_data pointer to a newly allocated buffer containing the
    ///     public key, if found. Unset if no record was found.
    ///     The Signal Protocol library is responsible for freeing this buffer.
    /// @param private_data pointer to a newly allocated buffer containing the
    ///     private key, if found. Unset if no record was found.
    ///     The Signal Protocol library is responsible for freeing this buffer.
    /// @return 0 on success, negative on failure
    pub get_identity_key_pair: ::std::option::Option<
        unsafe extern "C" fn(
            public_data: *mut *mut signal_buffer,
            private_data: *mut *mut signal_buffer,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Return the local client's registration ID.
    ///
    /// Clients should maintain a registration ID, a random number
    /// between 1 and 16380 that's generated once at install time.
    ///
    /// @param registration_id pointer to be set to the local client's
    ///     registration ID, if it was successfully retrieved.
    /// @return 0 on success, negative on failure
    pub get_local_registration_id: ::std::option::Option<
        unsafe extern "C" fn(
            user_data: *mut ::std::os::raw::c_void,
            registration_id: *mut u32,
        ) -> ::std::os::raw::c_int,
    >,
    /// Save a remote client's identity key
    /// <p>
    /// Store a remote client's identity key as trusted.
    /// The value of key_data may be null. In this case remove the key data
    /// from the identity store, but retain any metadata that may be kept
    /// alongside it.
    ///
    /// @param address the address of the remote client
    /// @param key_data Pointer to the remote client's identity key, may be
    /// null
    /// @param key_len Length of the remote client's identity key
    /// @return 0 on success, negative on failure
    pub save_identity: ::std::option::Option<
        unsafe extern "C" fn(
            address: *const signal_protocol_address,
            key_data: *mut u8,
            key_len: usize,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Verify a remote client's identity key.
    ///
    /// Determine whether a remote client's identity is trusted.  Convention is
    /// that the TextSecure protocol is 'trust on first use.'  This means that
    /// an identity key is considered 'trusted' if there is no entry for the
    /// recipient
    /// in the local store, or if it matches the saved key for a recipient in
    /// the local
    /// store.  Only if it mismatches an entry in the local store is it
    /// considered
    /// 'untrusted.'
    ///
    /// @param address the address of the remote client
    /// @param identityKey The identity key to verify.
    /// @param key_data Pointer to the identity key to verify
    /// @param key_len Length of the identity key to verify
    /// @return 1 if trusted, 0 if untrusted, negative on failure
    pub is_trusted_identity: ::std::option::Option<
        unsafe extern "C" fn(
            address: *const signal_protocol_address,
            key_data: *mut u8,
            key_len: usize,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Return the saved public identity key for a remote client.
    ///
    /// @param address the address of the remote client
    /// @return 0 on success, negative on failure
    pub get_identity: ::std::option::Option<
        unsafe extern "C" fn(
            address: *const signal_protocol_address,
            identity_data: *mut *mut signal_buffer,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Function called to perform cleanup when the data store context is being
    /// destroyed.
    pub destroy_func: ::std::option::Option<
        unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void),
    >,
    /// User data pointer
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_signal_protocol_identity_key_store() {
    assert_eq!(
        ::std::mem::size_of::<signal_protocol_identity_key_store>(),
        48usize,
        concat!("Size of: ", stringify!(signal_protocol_identity_key_store))
    );
    assert_eq!(
        ::std::mem::align_of::<signal_protocol_identity_key_store>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(signal_protocol_identity_key_store)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_identity_key_store>()))
                .get_identity_key_pair as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_identity_key_store),
            "::",
            stringify!(get_identity_key_pair)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_identity_key_store>()))
                .get_local_registration_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_identity_key_store),
            "::",
            stringify!(get_local_registration_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_identity_key_store>()))
                .save_identity as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_identity_key_store),
            "::",
            stringify!(save_identity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_identity_key_store>()))
                .is_trusted_identity as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_identity_key_store),
            "::",
            stringify!(is_trusted_identity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_identity_key_store>()))
                .destroy_func as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_identity_key_store),
            "::",
            stringify!(destroy_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_identity_key_store>()))
                .user_data as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_identity_key_store),
            "::",
            stringify!(user_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct signal_protocol_sender_key_store {
    /// Store a serialized sender key record for a given
    /// (groupId + senderId + deviceId) tuple.
    ///
    /// @param sender_key_name the (groupId + senderId + deviceId) tuple
    /// @param record pointer to a buffer containing the serialized record
    /// @param record_len length of the serialized record
    /// @param user_record pointer to a buffer containing application specific
    ///     data to be stored alongside the serialized record. If no such
    ///     data exists, then this pointer will be null.
    /// @param user_record_len length of the application specific data
    /// @return 0 on success, negative on failure
    pub store_sender_key: ::std::option::Option<
        unsafe extern "C" fn(
            sender_key_name: *const signal_protocol_sender_key_name,
            record: *mut u8,
            record_len: usize,
            user_record: *mut u8,
            user_record_len: usize,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Returns a copy of the sender key record corresponding to the
    /// (groupId + senderId + deviceId) tuple.
    ///
    /// @param record pointer to a newly allocated buffer containing the
    /// record,
    ///     if found. Unset if no record was found.
    ///     The Signal Protocol library is responsible for freeing this buffer.
    /// @param user_record pointer to a newly allocated buffer containing
    ///     application-specific data stored alongside the record. If no such
    ///     data exists, then this pointer may be left unset.
    ///     The Signal Protocol library is responsible for freeing this buffer.
    /// @param sender_key_name the (groupId + senderId + deviceId) tuple
    /// @return 1 if the record was loaded, 0 if the record was not found,
    /// negative on failure
    pub load_sender_key: ::std::option::Option<
        unsafe extern "C" fn(
            record: *mut *mut signal_buffer,
            user_record: *mut *mut signal_buffer,
            sender_key_name: *const signal_protocol_sender_key_name,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    /// Function called to perform cleanup when the data store context is being
    /// destroyed.
    pub destroy_func: ::std::option::Option<
        unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void),
    >,
    /// User data pointer
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_signal_protocol_sender_key_store() {
    assert_eq!(
        ::std::mem::size_of::<signal_protocol_sender_key_store>(),
        32usize,
        concat!("Size of: ", stringify!(signal_protocol_sender_key_store))
    );
    assert_eq!(
        ::std::mem::align_of::<signal_protocol_sender_key_store>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(signal_protocol_sender_key_store)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_sender_key_store>()))
                .store_sender_key as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_sender_key_store),
            "::",
            stringify!(store_sender_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_sender_key_store>()))
                .load_sender_key as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_sender_key_store),
            "::",
            stringify!(load_sender_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_sender_key_store>()))
                .destroy_func as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_sender_key_store),
            "::",
            stringify!(destroy_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<signal_protocol_sender_key_store>()))
                .user_data as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_protocol_sender_key_store),
            "::",
            stringify!(user_data)
        )
    );
}
extern "C" {
    /// Create a new instance of the global library context.
    pub fn signal_context_create(
        context: *mut *mut signal_context,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the crypto provider to be used by the Signal Protocol library.
    ///
    /// @param crypto_provider Populated structure of crypto provider function
    ///     pointers. The contents of this structure are copied, so the caller
    ///     does not need to maintain its instance.
    /// @return 0 on success, negative on failure
    pub fn signal_context_set_crypto_provider(
        context: *mut signal_context,
        crypto_provider: *const signal_crypto_provider,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the locking functions to be used by the Signal Protocol library for
    /// synchronization.
    ///
    /// Note: These functions must allow recursive locking (e.g.
    /// PTHREAD_MUTEX_RECURSIVE)
    ///
    /// @param lock function to lock a mutex
    /// @param unlock function to unlock a mutex
    /// @return 0 on success, negative on failure
    pub fn signal_context_set_locking_functions(
        context: *mut signal_context,
        lock: ::std::option::Option<
            unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void),
        >,
        unlock: ::std::option::Option<
            unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the log function to be used by the Signal Protocol library for
    /// logging.
    ///
    /// @return 0 on success, negative on failure
    pub fn signal_context_set_log_function(
        context: *mut signal_context,
        log: ::std::option::Option<
            unsafe extern "C" fn(
                level: ::std::os::raw::c_int,
                message: *const ::std::os::raw::c_char,
                len: usize,
                user_data: *mut ::std::os::raw::c_void,
            ),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_context_destroy(context: *mut signal_context);
}
extern "C" {
    /// Create a new instance of the Signal Protocol data store interface.
    pub fn signal_protocol_store_context_create(
        context: *mut *mut signal_protocol_store_context,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_store_context_set_session_store(
        context: *mut signal_protocol_store_context,
        store: *const signal_protocol_session_store,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_store_context_set_pre_key_store(
        context: *mut signal_protocol_store_context,
        store: *const signal_protocol_pre_key_store,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_store_context_set_signed_pre_key_store(
        context: *mut signal_protocol_store_context,
        store: *const signal_protocol_signed_pre_key_store,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_store_context_set_identity_key_store(
        context: *mut signal_protocol_store_context,
        store: *const signal_protocol_identity_key_store,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_store_context_set_sender_key_store(
        context: *mut signal_protocol_store_context,
        store: *const signal_protocol_sender_key_store,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_store_context_destroy(
        context: *mut signal_protocol_store_context,
    );
}
extern "C" {
    pub fn signal_protocol_session_load_session(
        context: *mut signal_protocol_store_context,
        record: *mut *mut session_record,
        address: *const signal_protocol_address,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_session_get_sub_device_sessions(
        context: *mut signal_protocol_store_context,
        sessions: *mut *mut signal_int_list,
        name: *const ::std::os::raw::c_char,
        name_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_session_store_session(
        context: *mut signal_protocol_store_context,
        address: *const signal_protocol_address,
        record: *mut session_record,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_session_contains_session(
        context: *mut signal_protocol_store_context,
        address: *const signal_protocol_address,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_session_delete_session(
        context: *mut signal_protocol_store_context,
        address: *const signal_protocol_address,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_session_delete_all_sessions(
        context: *mut signal_protocol_store_context,
        name: *const ::std::os::raw::c_char,
        name_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_pre_key_load_key(
        context: *mut signal_protocol_store_context,
        pre_key: *mut *mut session_pre_key,
        pre_key_id: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_pre_key_store_key(
        context: *mut signal_protocol_store_context,
        pre_key: *mut session_pre_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_pre_key_contains_key(
        context: *mut signal_protocol_store_context,
        pre_key_id: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_pre_key_remove_key(
        context: *mut signal_protocol_store_context,
        pre_key_id: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_signed_pre_key_load_key(
        context: *mut signal_protocol_store_context,
        pre_key: *mut *mut session_signed_pre_key,
        signed_pre_key_id: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_signed_pre_key_store_key(
        context: *mut signal_protocol_store_context,
        pre_key: *mut session_signed_pre_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_signed_pre_key_contains_key(
        context: *mut signal_protocol_store_context,
        signed_pre_key_id: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_signed_pre_key_remove_key(
        context: *mut signal_protocol_store_context,
        signed_pre_key_id: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_identity_get_key_pair(
        context: *mut signal_protocol_store_context,
        key_pair: *mut *mut ratchet_identity_key_pair,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_identity_get_local_registration_id(
        context: *mut signal_protocol_store_context,
        registration_id: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_identity_save_identity(
        context: *mut signal_protocol_store_context,
        address: *const signal_protocol_address,
        identity_key: *mut ec_public_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_identity_is_trusted_identity(
        context: *mut signal_protocol_store_context,
        address: *const signal_protocol_address,
        identity_key: *mut ec_public_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_identity_get_identity(
        context: *mut signal_protocol_store_context,
        address: *const signal_protocol_address,
        identity_buffer: *mut *mut signal_buffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_sender_key_store_key(
        context: *mut signal_protocol_store_context,
        sender_key_name: *const signal_protocol_sender_key_name,
        record: *mut sender_key_record,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_sender_key_load_key(
        context: *mut signal_protocol_store_context,
        record: *mut *mut sender_key_record,
        sender_key_name: *const signal_protocol_sender_key_name,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hkdf_create(
        context: *mut *mut hkdf_context,
        message_version: ::std::os::raw::c_int,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hkdf_derive_secrets(
        context: *mut hkdf_context,
        output: *mut *mut u8,
        input_key_material: *const u8,
        input_key_material_len: usize,
        salt: *const u8,
        salt_len: usize,
        info: *const u8,
        info_len: usize,
        output_len: usize,
    ) -> isize;
}
extern "C" {
    pub fn hkdf_compare(
        context1: *const hkdf_context,
        context2: *const hkdf_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hkdf_destroy(type_: *mut signal_type_base);
}
extern "C" {
    pub fn ciphertext_message_get_type(
        message: *const ciphertext_message,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ciphertext_message_get_serialized(
        message: *const ciphertext_message,
    ) -> *mut signal_buffer;
}
extern "C" {
    pub fn signal_message_create(
        message: *mut *mut signal_message,
        message_version: u8,
        mac_key: *const u8,
        mac_key_len: usize,
        sender_ratchet_key: *mut ec_public_key,
        counter: u32,
        previous_counter: u32,
        ciphertext: *const u8,
        ciphertext_len: usize,
        sender_identity_key: *mut ec_public_key,
        receiver_identity_key: *mut ec_public_key,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_message_deserialize(
        message: *mut *mut signal_message,
        data: *const u8,
        len: usize,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_message_copy(
        message: *mut *mut signal_message,
        other_message: *mut signal_message,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_message_get_sender_ratchet_key(
        message: *const signal_message,
    ) -> *mut ec_public_key;
}
extern "C" {
    pub fn signal_message_get_message_version(
        message: *const signal_message,
    ) -> u8;
}
extern "C" {
    pub fn signal_message_get_counter(message: *const signal_message) -> u32;
}
extern "C" {
    pub fn signal_message_get_body(
        message: *const signal_message,
    ) -> *mut signal_buffer;
}
extern "C" {
    /// Verify the MAC on the Signal message.
    ///
    /// @return 1 if verified, 0 if invalid, negative on error
    pub fn signal_message_verify_mac(
        message: *mut signal_message,
        sender_identity_key: *mut ec_public_key,
        receiver_identity_key: *mut ec_public_key,
        mac_key: *const u8,
        mac_key_len: usize,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_message_is_legacy(
        data: *const u8,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_message_destroy(type_: *mut signal_type_base);
}
extern "C" {
    pub fn pre_key_signal_message_create(
        pre_key_message: *mut *mut pre_key_signal_message,
        message_version: u8,
        registration_id: u32,
        pre_key_id: *const u32,
        signed_pre_key_id: u32,
        base_key: *mut ec_public_key,
        identity_key: *mut ec_public_key,
        message: *mut signal_message,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pre_key_signal_message_deserialize(
        message: *mut *mut pre_key_signal_message,
        data: *const u8,
        len: usize,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pre_key_signal_message_copy(
        message: *mut *mut pre_key_signal_message,
        other_message: *mut pre_key_signal_message,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pre_key_signal_message_get_message_version(
        message: *const pre_key_signal_message,
    ) -> u8;
}
extern "C" {
    pub fn pre_key_signal_message_get_identity_key(
        message: *const pre_key_signal_message,
    ) -> *mut ec_public_key;
}
extern "C" {
    pub fn pre_key_signal_message_get_registration_id(
        message: *const pre_key_signal_message,
    ) -> u32;
}
extern "C" {
    pub fn pre_key_signal_message_has_pre_key_id(
        message: *const pre_key_signal_message,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pre_key_signal_message_get_pre_key_id(
        message: *const pre_key_signal_message,
    ) -> u32;
}
extern "C" {
    pub fn pre_key_signal_message_get_signed_pre_key_id(
        message: *const pre_key_signal_message,
    ) -> u32;
}
extern "C" {
    pub fn pre_key_signal_message_get_base_key(
        message: *const pre_key_signal_message,
    ) -> *mut ec_public_key;
}
extern "C" {
    pub fn pre_key_signal_message_get_signal_message(
        message: *const pre_key_signal_message,
    ) -> *mut signal_message;
}
extern "C" {
    pub fn pre_key_signal_message_destroy(type_: *mut signal_type_base);
}
extern "C" {
    pub fn sender_key_message_create(
        message: *mut *mut sender_key_message,
        key_id: u32,
        iteration: u32,
        ciphertext: *const u8,
        ciphertext_len: usize,
        signature_key: *mut ec_private_key,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_key_message_deserialize(
        message: *mut *mut sender_key_message,
        data: *const u8,
        len: usize,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_key_message_copy(
        message: *mut *mut sender_key_message,
        other_message: *mut sender_key_message,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_key_message_get_key_id(
        message: *mut sender_key_message,
    ) -> u32;
}
extern "C" {
    pub fn sender_key_message_get_iteration(
        message: *mut sender_key_message,
    ) -> u32;
}
extern "C" {
    pub fn sender_key_message_get_ciphertext(
        message: *mut sender_key_message,
    ) -> *mut signal_buffer;
}
extern "C" {
    pub fn sender_key_message_verify_signature(
        message: *mut sender_key_message,
        signature_key: *mut ec_public_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_key_message_destroy(type_: *mut signal_type_base);
}
extern "C" {
    pub fn sender_key_distribution_message_create(
        message: *mut *mut sender_key_distribution_message,
        id: u32,
        iteration: u32,
        chain_key: *const u8,
        chain_key_len: usize,
        signature_key: *mut ec_public_key,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_key_distribution_message_deserialize(
        message: *mut *mut sender_key_distribution_message,
        data: *const u8,
        len: usize,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_key_distribution_message_copy(
        message: *mut *mut sender_key_distribution_message,
        other_message: *mut sender_key_distribution_message,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_key_distribution_message_get_id(
        message: *mut sender_key_distribution_message,
    ) -> u32;
}
extern "C" {
    pub fn sender_key_distribution_message_get_iteration(
        message: *mut sender_key_distribution_message,
    ) -> u32;
}
extern "C" {
    pub fn sender_key_distribution_message_get_chain_key(
        message: *mut sender_key_distribution_message,
    ) -> *mut signal_buffer;
}
extern "C" {
    pub fn sender_key_distribution_message_get_signature_key(
        message: *mut sender_key_distribution_message,
    ) -> *mut ec_public_key;
}
extern "C" {
    pub fn sender_key_distribution_message_destroy(
        type_: *mut signal_type_base,
    );
}
extern "C" {
    pub fn session_state_create(
        state: *mut *mut session_state,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_state_serialize(
        buffer: *mut *mut signal_buffer,
        state: *mut session_state,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_state_deserialize(
        state: *mut *mut session_state,
        data: *const u8,
        len: usize,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_state_copy(
        state: *mut *mut session_state,
        other_state: *mut session_state,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_state_set_session_version(
        state: *mut session_state,
        version: u32,
    );
}
extern "C" {
    pub fn session_state_get_session_version(
        state: *const session_state,
    ) -> u32;
}
extern "C" {
    pub fn session_state_set_local_identity_key(
        state: *mut session_state,
        identity_key: *mut ec_public_key,
    );
}
extern "C" {
    pub fn session_state_get_local_identity_key(
        state: *const session_state,
    ) -> *mut ec_public_key;
}
extern "C" {
    pub fn session_state_set_remote_identity_key(
        state: *mut session_state,
        identity_key: *mut ec_public_key,
    );
}
extern "C" {
    pub fn session_state_get_remote_identity_key(
        state: *const session_state,
    ) -> *mut ec_public_key;
}
extern "C" {
    pub fn session_state_set_root_key(
        state: *mut session_state,
        root_key: *mut ratchet_root_key,
    );
}
extern "C" {
    pub fn session_state_get_root_key(
        state: *const session_state,
    ) -> *mut ratchet_root_key;
}
extern "C" {
    pub fn session_state_set_previous_counter(
        state: *mut session_state,
        counter: u32,
    );
}
extern "C" {
    pub fn session_state_get_previous_counter(
        state: *const session_state,
    ) -> u32;
}
extern "C" {
    pub fn session_state_set_sender_chain(
        state: *mut session_state,
        sender_ratchet_key_pair: *mut ec_key_pair,
        chain_key: *mut ratchet_chain_key,
    );
}
extern "C" {
    pub fn session_state_get_sender_ratchet_key(
        state: *const session_state,
    ) -> *mut ec_public_key;
}
extern "C" {
    pub fn session_state_get_sender_ratchet_key_pair(
        state: *const session_state,
    ) -> *mut ec_key_pair;
}
extern "C" {
    pub fn session_state_get_sender_chain_key(
        state: *const session_state,
    ) -> *mut ratchet_chain_key;
}
extern "C" {
    pub fn session_state_set_sender_chain_key(
        state: *mut session_state,
        chain_key: *mut ratchet_chain_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_state_has_sender_chain(
        state: *const session_state,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_state_has_message_keys(
        state: *mut session_state,
        sender_ephemeral: *mut ec_public_key,
        counter: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_state_remove_message_keys(
        state: *mut session_state,
        message_keys_result: *mut ratchet_message_keys,
        sender_ephemeral: *mut ec_public_key,
        counter: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_state_set_message_keys(
        state: *mut session_state,
        sender_ephemeral: *mut ec_public_key,
        message_keys: *mut ratchet_message_keys,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_state_add_receiver_chain(
        state: *mut session_state,
        sender_ratchet_key: *mut ec_public_key,
        chain_key: *mut ratchet_chain_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_state_set_receiver_chain_key(
        state: *mut session_state,
        sender_ephemeral: *mut ec_public_key,
        chain_key: *mut ratchet_chain_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_state_get_receiver_chain_key(
        state: *mut session_state,
        sender_ephemeral: *mut ec_public_key,
    ) -> *mut ratchet_chain_key;
}
extern "C" {
    pub fn session_state_set_pending_key_exchange(
        state: *mut session_state,
        sequence: u32,
        our_base_key: *mut ec_key_pair,
        our_ratchet_key: *mut ec_key_pair,
        our_identity_key: *mut ratchet_identity_key_pair,
    );
}
extern "C" {
    pub fn session_state_get_pending_key_exchange_sequence(
        state: *mut session_state,
    ) -> u32;
}
extern "C" {
    pub fn session_state_get_pending_key_exchange_base_key(
        state: *const session_state,
    ) -> *mut ec_key_pair;
}
extern "C" {
    pub fn session_state_get_pending_key_exchange_ratchet_key(
        state: *const session_state,
    ) -> *mut ec_key_pair;
}
extern "C" {
    pub fn session_state_get_pending_key_exchange_identity_key(
        state: *const session_state,
    ) -> *mut ratchet_identity_key_pair;
}
extern "C" {
    pub fn session_state_has_pending_key_exchange(
        state: *const session_state,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_state_set_unacknowledged_pre_key_message(
        state: *mut session_state,
        pre_key_id: *const u32,
        signed_pre_key_id: u32,
        base_key: *mut ec_public_key,
    );
}
extern "C" {
    pub fn session_state_unacknowledged_pre_key_message_has_pre_key_id(
        state: *const session_state,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_state_unacknowledged_pre_key_message_get_pre_key_id(
        state: *const session_state,
    ) -> u32;
}
extern "C" {
    pub fn session_state_unacknowledged_pre_key_message_get_signed_pre_key_id(
        state: *const session_state,
    ) -> u32;
}
extern "C" {
    pub fn session_state_unacknowledged_pre_key_message_get_base_key(
        state: *const session_state,
    ) -> *mut ec_public_key;
}
extern "C" {
    pub fn session_state_has_unacknowledged_pre_key_message(
        state: *const session_state,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_state_clear_unacknowledged_pre_key_message(
        state: *mut session_state,
    );
}
extern "C" {
    pub fn session_state_set_remote_registration_id(
        state: *mut session_state,
        id: u32,
    );
}
extern "C" {
    pub fn session_state_get_remote_registration_id(
        state: *const session_state,
    ) -> u32;
}
extern "C" {
    pub fn session_state_set_local_registration_id(
        state: *mut session_state,
        id: u32,
    );
}
extern "C" {
    pub fn session_state_get_local_registration_id(
        state: *const session_state,
    ) -> u32;
}
extern "C" {
    pub fn session_state_set_needs_refresh(
        state: *mut session_state,
        value: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn session_state_get_needs_refresh(
        state: *const session_state,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_state_set_alice_base_key(
        state: *mut session_state,
        key: *mut ec_public_key,
    );
}
extern "C" {
    pub fn session_state_get_alice_base_key(
        state: *const session_state,
    ) -> *mut ec_public_key;
}
extern "C" {
    pub fn session_state_destroy(type_: *mut signal_type_base);
}
extern "C" {
    /// Constructs a session builder.
    ///
    /// The store and global contexts must remain valid for the lifetime of the
    /// session builder.
    ///
    /// When finished, free the returned instance by calling
    /// session_builder_free().
    ///
    /// @param builder set to a freshly allocated session builder instance
    /// @param store the signal_protocol_store_context to store all state
    /// information in
    /// @param remote_address the address of the remote user to build a session
    /// with
    /// @param global_context the global library context
    /// @return 0 on success, or negative on failure
    pub fn session_builder_create(
        builder: *mut *mut session_builder,
        store: *mut signal_protocol_store_context,
        remote_address: *const signal_protocol_address,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Build a new session from a session_pre_key_bundle retrieved from a
    /// server.
    ///
    /// @param bundle A pre key bundle for the destination recipient, retrieved
    /// from a server.
    /// @retval SG_SUCCESS Success
    /// @retval SG_ERR_INVALID_KEY when the session_pre_key_bundle is badly
    /// formatted.
    /// @retval SG_ERR_UNTRUSTED_IDENTITY when the sender's identity key is not
    /// trusted.
    pub fn session_builder_process_pre_key_bundle(
        builder: *mut session_builder,
        bundle: *mut session_pre_key_bundle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_builder_free(builder: *mut session_builder);
}
extern "C" {
    /// Construct a session cipher for encrypt/decrypt operations on a session.
    /// In order to use session_cipher, a session must have already been created
    /// and stored using session_builder.
    ///
    /// The store and global contexts must remain valid for the lifetime of the
    /// session cipher.
    ///
    /// When finished, free the returned instance by calling
    /// session_cipher_free().
    ///
    /// @param cipher set to a freshly allocated session cipher instance
    /// @param store the signal_protocol_store_context to store all state
    /// information in
    /// @param remote_address the remote address that messages will be encrypted
    /// to or decrypted from.
    /// @param global_context the global library context
    /// @return 0 on success, or negative on failure
    pub fn session_cipher_create(
        cipher: *mut *mut session_cipher,
        store: *mut signal_protocol_store_context,
        remote_address: *const signal_protocol_address,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the optional user data pointer for the session cipher.
    ///
    /// This is to give callback functions a way of accessing app specific
    /// context information for this cipher.
    pub fn session_cipher_set_user_data(
        cipher: *mut session_cipher,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    /// Get the optional user data pointer for the session cipher.
    ///
    /// This is to give callback functions a way of accessing app specific
    /// context information for this cipher.
    pub fn session_cipher_get_user_data(
        cipher: *mut session_cipher,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Set the callback function that is called during the decrypt process.
    ///
    /// The callback function is called from within
    /// session_cipher_decrypt_pre_key_signal_message() and
    /// session_cipher_decrypt_signal_message() after decryption is complete
    /// but before the updated session state has been committed to the session
    /// store. If the callback function returns a negative value, then the
    /// decrypt function will immediately fail with an error.
    ///
    /// This a callback allows some implementations to store the committed
    /// plaintext
    /// to their local message store first, in case they are concerned with a
    /// crash
    /// or write error happening between the time the session state is updated
    /// but
    /// before they're able to successfully store the plaintext to disk.
    ///
    /// @param callback the callback function to set
    pub fn session_cipher_set_decryption_callback(
        cipher: *mut session_cipher,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                cipher: *mut session_cipher,
                plaintext: *mut signal_buffer,
                decrypt_context: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    /// Encrypt a message.
    ///
    /// @param padded_message The plaintext message bytes, optionally padded to
    /// a constant multiple.
    /// @param padded_message_len The length of the data pointed to by
    /// padded_message
    /// @param encrypted_message Set to a ciphertext message encrypted to the
    /// recipient+device tuple.
    ///
    /// @return SG_SUCCESS on success, negative on error
    pub fn session_cipher_encrypt(
        cipher: *mut session_cipher,
        padded_message: *const u8,
        padded_message_len: usize,
        encrypted_message: *mut *mut ciphertext_message,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Decrypt a message.
    ///
    /// @param ciphertext The pre_key_signal_message to decrypt.
    /// @param decrypt_context Optional context pointer associated with the
    ///   ciphertext, which is passed to the decryption callback function
    /// @param plaintext Set to a newly allocated buffer containing the
    /// plaintext.
    ///
    /// @retval SG_SUCCESS Success
    /// @retval SG_ERR_INVALID_MESSAGE if the input is not valid ciphertext.
    /// @retval SG_ERR_DUPLICATE_MESSAGE if the input is a message that has
    /// already been received.
    /// @retval SG_ERR_LEGACY_MESSAGE if the input is a message formatted by a
    /// protocol version that
    ///                               is no longer supported.
    /// @retval SG_ERR_INVALID_KEY_ID when there is no local pre_key_record
    ///                               that corresponds to the pre key ID in the
    /// message.
    /// @retval SG_ERR_INVALID_KEY when the message is formatted incorrectly.
    /// @retval SG_ERR_UNTRUSTED_IDENTITY when the identity key of the sender is
    /// untrusted.
    pub fn session_cipher_decrypt_pre_key_signal_message(
        cipher: *mut session_cipher,
        ciphertext: *mut pre_key_signal_message,
        decrypt_context: *mut ::std::os::raw::c_void,
        plaintext: *mut *mut signal_buffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Decrypt a message.
    ///
    /// @param ciphertext The signal_message to decrypt.
    /// @param decrypt_context Optional context pointer associated with the
    ///   ciphertext, which is passed to the decryption callback function
    /// @param plaintext Set to a newly allocated buffer containing the
    /// plaintext.
    ///
    /// @retval SG_SUCCESS Success
    /// @retval SG_ERR_INVALID_MESSAGE if the input is not valid ciphertext.
    /// @retval SG_ERR_DUPLICATE_MESSAGE if the input is a message that has
    /// already been received.
    /// @retval SG_ERR_LEGACY_MESSAGE if the input is a message formatted by a
    /// protocol version that
    ///                               is no longer supported.
    /// @retval SG_ERR_NO_SESSION if there is no established session for this
    /// contact.
    pub fn session_cipher_decrypt_signal_message(
        cipher: *mut session_cipher,
        ciphertext: *mut signal_message,
        decrypt_context: *mut ::std::os::raw::c_void,
        plaintext: *mut *mut signal_buffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Gets the remote registration ID for this session cipher.
    ///
    /// @param remote_id Set to the value of the remote registration ID
    ///
    /// @return SG_SUCCESS on success, negative on error
    pub fn session_cipher_get_remote_registration_id(
        cipher: *mut session_cipher,
        remote_id: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Gets the version of the session associated with this session cipher.
    ///
    /// @param version Set to the value of the session version
    ///
    /// @retval SG_SUCCESS Success
    /// @retval SG_ERR_NO_SESSION if no session could be found
    pub fn session_cipher_get_session_version(
        cipher: *mut session_cipher,
        version: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn session_cipher_free(cipher: *mut session_cipher);
}
extern "C" {
    /// Generate an identity key pair.  Clients should only do this once,
    /// at install time.
    ///
    /// @param key_pair the generated identity key pair
    /// @return 0 on success, or negative on failure
    pub fn signal_protocol_key_helper_generate_identity_key_pair(
        key_pair: *mut *mut ratchet_identity_key_pair,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Generate a registration ID.  Clients should only do this once,
    /// at install time.
    ///
    /// @param registration_id set to the generated registration ID
    /// @param extended_range By default (0), the generated registration
    ///                      ID is sized to require the minimal possible
    /// protobuf
    ///                      encoding overhead. Specify true (1) if the caller
    /// needs
    ///                      the full range of MAX_INT at the cost of slightly
    ///                      higher encoding overhead.
    /// @return 0 on success, or negative on failure
    pub fn signal_protocol_key_helper_generate_registration_id(
        registration_id: *mut u32,
        extended_range: ::std::os::raw::c_int,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Generate a random number between 0 (inclusive) and the provided maximum
    /// (exclusive).
    ///
    /// @param value set to the next random number
    /// @param max the maximum bound on the value of the random number
    /// @return 0 on success, or negative on failure
    pub fn signal_protocol_key_helper_get_random_sequence(
        value: *mut ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Generate a list of PreKeys.  Clients should do this at install time, and
    /// subsequently any time the list of PreKeys stored on the server runs low.
    ///
    /// Pre key IDs are shorts, so they will eventually be repeated.  Clients
    /// should
    /// store pre keys in a circular buffer, so that they are repeated as
    /// infrequently
    /// as possible.
    ///
    /// When finished with this list, the caller should free it by calling
    /// signal_protocol_key_helper_key_list_free().
    ///
    /// @param head pointer to the head of the key list
    /// @param start the starting pre key ID, inclusive.
    /// @param count the number of pre keys to generate.
    /// @return 0 on success, or negative on failure
    pub fn signal_protocol_key_helper_generate_pre_keys(
        head: *mut *mut signal_protocol_key_helper_pre_key_list_node,
        start: ::std::os::raw::c_uint,
        count: ::std::os::raw::c_uint,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the pre key element for the current node in the key list.
    ///
    /// @param node current list node
    /// @return pre key element
    pub fn signal_protocol_key_helper_key_list_element(
        node: *const signal_protocol_key_helper_pre_key_list_node,
    ) -> *mut session_pre_key;
}
extern "C" {
    /// Get the next element in the key list.
    ///
    /// @param node current list node
    /// @return next list node, or 0 if at the end of the list
    pub fn signal_protocol_key_helper_key_list_next(
        node: *const signal_protocol_key_helper_pre_key_list_node,
    ) -> *mut signal_protocol_key_helper_pre_key_list_node;
}
extern "C" {
    /// Free the key list.
    ///
    /// @param head pointer to the head of the list to free
    pub fn signal_protocol_key_helper_key_list_free(
        head: *mut signal_protocol_key_helper_pre_key_list_node,
    );
}
extern "C" {
    /// Generate a signed pre key
    ///
    /// @param signed_pre_key set to the generated pre key
    /// @param identity_key_pair the local client's identity key pair.
    /// @param signed_pre_key_id the pre key ID to assign the generated signed
    /// pre key
    /// @param timestamp the current time in milliseconds since the UNIX epoch
    ///
    /// @return 0 on success, or negative on failure
    pub fn signal_protocol_key_helper_generate_signed_pre_key(
        signed_pre_key: *mut *mut session_signed_pre_key,
        identity_key_pair: *const ratchet_identity_key_pair,
        signed_pre_key_id: u32,
        timestamp: u64,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_key_helper_generate_sender_signing_key(
        key_pair: *mut *mut ec_key_pair,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_key_helper_generate_sender_key(
        key_buffer: *mut *mut signal_buffer,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn signal_protocol_key_helper_generate_sender_key_id(
        key_id: *mut u32,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_message_key_create(
        key: *mut *mut sender_message_key,
        iteration: u32,
        seed: *mut signal_buffer,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_message_key_get_iteration(
        key: *mut sender_message_key,
    ) -> u32;
}
extern "C" {
    pub fn sender_message_key_get_iv(
        key: *mut sender_message_key,
    ) -> *mut signal_buffer;
}
extern "C" {
    pub fn sender_message_key_get_cipher_key(
        key: *mut sender_message_key,
    ) -> *mut signal_buffer;
}
extern "C" {
    pub fn sender_message_key_get_seed(
        key: *mut sender_message_key,
    ) -> *mut signal_buffer;
}
extern "C" {
    pub fn sender_message_key_destroy(type_: *mut signal_type_base);
}
extern "C" {
    pub fn sender_chain_key_create(
        key: *mut *mut sender_chain_key,
        iteration: u32,
        chain_key: *mut signal_buffer,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_chain_key_get_iteration(key: *mut sender_chain_key) -> u32;
}
extern "C" {
    pub fn sender_chain_key_create_message_key(
        key: *mut sender_chain_key,
        message_key: *mut *mut sender_message_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_chain_key_create_next(
        key: *mut sender_chain_key,
        next_key: *mut *mut sender_chain_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_chain_key_get_seed(
        key: *mut sender_chain_key,
    ) -> *mut signal_buffer;
}
extern "C" {
    pub fn sender_chain_key_destroy(type_: *mut signal_type_base);
}
extern "C" {
    pub fn sender_key_state_create(
        state: *mut *mut sender_key_state,
        id: u32,
        chain_key: *mut sender_chain_key,
        signature_public_key: *mut ec_public_key,
        signature_private_key: *mut ec_private_key,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_key_state_serialize(
        buffer: *mut *mut signal_buffer,
        state: *mut sender_key_state,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_key_state_deserialize(
        state: *mut *mut sender_key_state,
        data: *const u8,
        len: usize,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_key_state_copy(
        state: *mut *mut sender_key_state,
        other_state: *mut sender_key_state,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_key_state_get_key_id(state: *mut sender_key_state) -> u32;
}
extern "C" {
    pub fn sender_key_state_get_chain_key(
        state: *mut sender_key_state,
    ) -> *mut sender_chain_key;
}
extern "C" {
    pub fn sender_key_state_set_chain_key(
        state: *mut sender_key_state,
        chain_key: *mut sender_chain_key,
    );
}
extern "C" {
    pub fn sender_key_state_get_signing_key_public(
        state: *mut sender_key_state,
    ) -> *mut ec_public_key;
}
extern "C" {
    pub fn sender_key_state_get_signing_key_private(
        state: *mut sender_key_state,
    ) -> *mut ec_private_key;
}
extern "C" {
    pub fn sender_key_state_has_sender_message_key(
        state: *mut sender_key_state,
        iteration: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_key_state_add_sender_message_key(
        state: *mut sender_key_state,
        message_key: *mut sender_message_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sender_key_state_remove_sender_message_key(
        state: *mut sender_key_state,
        iteration: u32,
    ) -> *mut sender_message_key;
}
extern "C" {
    pub fn sender_key_state_destroy(type_: *mut signal_type_base);
}
extern "C" {
    /// Constructs a group session builder.
    ///
    /// The store and global contexts must remain valid for the lifetime of the
    /// session builder.
    ///
    /// When finished, free the returned instance by calling
    /// group_session_builder_free().
    ///
    /// @param builder set to a freshly allocated group session builder instance
    /// @param store the signal_protocol_store_context to store all state
    /// information in
    /// @param global_context the global library context
    /// @return 0 on success, or negative on failure
    pub fn group_session_builder_create(
        builder: *mut *mut group_session_builder,
        store: *mut signal_protocol_store_context,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Construct a group session for receiving messages from senderKeyName.
    ///
    /// @param sender_key_name the (groupId, senderId, deviceId) tuple
    /// associated
    ///     with the sender_key_distribution_message
    /// @param distribution_message a received sender_key_distribution_message
    /// @return 0 on success, or negative on failure
    pub fn group_session_builder_process_session(
        builder: *mut group_session_builder,
        sender_key_name: *const signal_protocol_sender_key_name,
        distribution_message: *mut sender_key_distribution_message,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Construct a group session for sending messages.
    ///
    /// @param distribution_message a distribution message to be allocated and
    /// populated
    /// @param sender_key_name the (groupId, senderId, deviceId) tuple. In this
    ///     case, the sender should be the caller
    /// @return 0 on success, or negative on failure
    pub fn group_session_builder_create_session(
        builder: *mut group_session_builder,
        distribution_message: *mut *mut sender_key_distribution_message,
        sender_key_name: *const signal_protocol_sender_key_name,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn group_session_builder_free(builder: *mut group_session_builder);
}
extern "C" {
    /// Construct a group cipher for encrypt/decrypt operations.
    ///
    /// The store and global contexts must remain valid for the lifetime of the
    /// group cipher.
    ///
    /// When finished, free the returned instance by calling
    /// group_cipher_free().
    ///
    /// @param cipher set to a freshly allocated group cipher instance
    /// @param store the signal_protocol_store_context to store all state
    /// information in
    /// @param sender_key_id the sender that messages will be encrypted to or
    /// decrypted from
    /// @param global_context the global library context
    /// @return 0 on success, or negative on failure
    pub fn group_cipher_create(
        cipher: *mut *mut group_cipher,
        store: *mut signal_protocol_store_context,
        sender_key_id: *const signal_protocol_sender_key_name,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the optional user data pointer for the group cipher.
    ///
    /// This is to give callback functions a way of accessing app specific
    /// context information for this cipher.
    pub fn group_cipher_set_user_data(
        cipher: *mut group_cipher,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    /// Get the optional user data pointer for the group cipher.
    ///
    /// This is to give callback functions a way of accessing app specific
    /// context information for this cipher.
    pub fn group_cipher_get_user_data(
        cipher: *mut group_cipher,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Set the callback function that is called during the decrypt process.
    ///
    /// The callback function is called from within group_cipher_decrypt() after
    /// decryption is complete but before the updated session state has been
    /// committed to the session store. If the callback function returns a
    /// negative value, then the decrypt function will immediately fail with
    /// an error.
    ///
    /// This a callback allows some implementations to store the committed
    /// plaintext
    /// to their local message store first, in case they are concerned with a
    /// crash
    /// or write error happening between the time the session state is updated
    /// but
    /// before they're able to successfully store the plaintext to disk.
    ///
    /// @param callback the callback function to set
    pub fn group_cipher_set_decryption_callback(
        cipher: *mut group_cipher,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                cipher: *mut group_cipher,
                plaintext: *mut signal_buffer,
                decrypt_context: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    /// Encrypt a message.
    ///
    /// @param padded_plaintext The plaintext message bytes, optionally padded
    /// to a constant multiple.
    /// @param padded_plaintext_len The length of the data pointed to by
    /// padded_message
    /// @param encrypted_message Set to a ciphertext message encrypted to the
    /// group+sender+device tuple.
    ///
    /// @retval SG_SUCCESS Success
    /// @retval SG_ERR_NO_SESSION if there is no established session for this
    /// contact.
    /// @retval SG_ERR_INVALID_KEY if there is no valid private key for this
    /// session.
    pub fn group_cipher_encrypt(
        cipher: *mut group_cipher,
        padded_plaintext: *const u8,
        padded_plaintext_len: usize,
        encrypted_message: *mut *mut ciphertext_message,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Decrypt a message.
    ///
    /// @param ciphertext The sender_key_message to decrypt.
    /// @param decrypt_context Optional context pointer associated with the
    ///   ciphertext, which is passed to the decryption callback function
    /// @param plaintext Set to a newly allocated buffer containing the
    /// plaintext.
    ///
    /// @retval SG_SUCCESS Success
    /// @retval SG_ERR_INVALID_MESSAGE if the input is not valid ciphertext.
    /// @retval SG_ERR_DUPLICATE_MESSAGE if the input is a message that has
    /// already been received.
    /// @retval SG_ERR_LEGACY_MESSAGE if the input is a message formatted by a
    /// protocol version that
    ///                               is no longer supported.
    /// @retval SG_ERR_NO_SESSION if there is no established session for this
    /// contact.
    pub fn group_cipher_decrypt(
        cipher: *mut group_cipher,
        ciphertext: *mut sender_key_message,
        decrypt_context: *mut ::std::os::raw::c_void,
        plaintext: *mut *mut signal_buffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn group_cipher_free(cipher: *mut group_cipher);
}
extern "C" {
    pub fn device_consistency_signature_create(
        signature: *mut *mut device_consistency_signature,
        signature_data: *const u8,
        signature_len: usize,
        vrf_output_data: *const u8,
        vrf_output_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_consistency_signature_get_signature(
        signature: *const device_consistency_signature,
    ) -> *mut signal_buffer;
}
extern "C" {
    pub fn device_consistency_signature_get_vrf_output(
        signature: *const device_consistency_signature,
    ) -> *mut signal_buffer;
}
extern "C" {
    pub fn device_consistency_signature_destroy(type_: *mut signal_type_base);
}
extern "C" {
    pub fn device_consistency_commitment_create(
        commitment: *mut *mut device_consistency_commitment,
        generation: u32,
        identity_key_list: *mut ec_public_key_list,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_consistency_commitment_get_generation(
        commitment: *const device_consistency_commitment,
    ) -> u32;
}
extern "C" {
    pub fn device_consistency_commitment_get_serialized(
        commitment: *const device_consistency_commitment,
    ) -> *mut signal_buffer;
}
extern "C" {
    pub fn device_consistency_commitment_destroy(type_: *mut signal_type_base);
}
extern "C" {
    pub fn device_consistency_message_create_from_pair(
        message: *mut *mut device_consistency_message,
        commitment: *mut device_consistency_commitment,
        identity_key_pair: *mut ec_key_pair,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_consistency_message_create_from_serialized(
        message: *mut *mut device_consistency_message,
        commitment: *mut device_consistency_commitment,
        serialized_data: *const u8,
        serialized_len: usize,
        identity_key: *mut ec_public_key,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_consistency_message_get_serialized(
        message: *const device_consistency_message,
    ) -> *mut signal_buffer;
}
extern "C" {
    pub fn device_consistency_message_get_signature(
        message: *const device_consistency_message,
    ) -> *mut device_consistency_signature;
}
extern "C" {
    pub fn device_consistency_signature_get_generation(
        message: *const device_consistency_message,
    ) -> u32;
}
extern "C" {
    pub fn device_consistency_message_destroy(type_: *mut signal_type_base);
}
extern "C" {
    pub fn device_consistency_code_generate_for(
        commitment: *mut device_consistency_commitment,
        signatures: *mut device_consistency_signature_list,
        code_string: *mut *mut ::std::os::raw::c_char,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_consistency_signature_list_alloc(
    ) -> *mut device_consistency_signature_list;
}
extern "C" {
    pub fn device_consistency_signature_list_copy(
        list: *const device_consistency_signature_list,
    ) -> *mut device_consistency_signature_list;
}
extern "C" {
    pub fn device_consistency_signature_list_push_back(
        list: *mut device_consistency_signature_list,
        value: *mut device_consistency_signature,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_consistency_signature_list_size(
        list: *const device_consistency_signature_list,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn device_consistency_signature_list_at(
        list: *const device_consistency_signature_list,
        index: ::std::os::raw::c_uint,
    ) -> *mut device_consistency_signature;
}
extern "C" {
    pub fn device_consistency_signature_list_free(
        list: *mut device_consistency_signature_list,
    );
}
extern "C" {
    /// Generate a scannable and displayble fingerprint.
    ///
    /// @param local_stable_identifier The client's "stable" identifier.
    /// @param local_identity_key The client's identity key.
    /// @param remote_stable_identifier The remote party's "stable" identifier.
    /// @param remote_identity_key The remote party's identity key.
    /// @param fingerprint_val Set to a freshly allocated unique fingerprint for
    /// this conversation
    /// @return 0 on success, or negative on failure
    pub fn fingerprint_generator_create_for(
        generator: *mut fingerprint_generator,
        local_stable_identifier: *const ::std::os::raw::c_char,
        local_identity_key: *const ec_public_key,
        remote_stable_identifier: *const ::std::os::raw::c_char,
        remote_identity_key: *const ec_public_key,
        fingerprint_val: *mut *mut fingerprint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Generate a scannable and displayble fingerprint for a list of keys
    ///
    /// @param local_stable_identifier The client's "stable" identifier.
    /// @param local_identity_key_list The client's identity key list.
    /// @param remote_stable_identifier The remote party's "stable" identifier.
    /// @param remote_identity_key_list The remote party's identity key list.
    /// @param fingerprint_val Set to a freshly allocated unique fingerprint for
    /// this conversation
    /// @return 0 on success, or negative on failure
    pub fn fingerprint_generator_create_for_list(
        generator: *mut fingerprint_generator,
        local_stable_identifier: *const ::std::os::raw::c_char,
        local_identity_key_list: *const ec_public_key_list,
        remote_stable_identifier: *const ::std::os::raw::c_char,
        remote_identity_key_list: *const ec_public_key_list,
        fingerprint_val: *mut *mut fingerprint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fingerprint_generator_free(generator: *mut fingerprint_generator);
}
extern "C" {
    pub fn fingerprint_create(
        fingerprint_val: *mut *mut fingerprint,
        displayable: *mut displayable_fingerprint,
        scannable: *mut scannable_fingerprint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fingerprint_get_displayable(
        fingerprint_val: *const fingerprint,
    ) -> *mut displayable_fingerprint;
}
extern "C" {
    pub fn fingerprint_get_scannable(
        fingerprint_val: *const fingerprint,
    ) -> *mut scannable_fingerprint;
}
extern "C" {
    pub fn fingerprint_destroy(type_: *mut signal_type_base);
}
extern "C" {
    pub fn displayable_fingerprint_create(
        displayable: *mut *mut displayable_fingerprint,
        local_fingerprint: *const ::std::os::raw::c_char,
        remote_fingerprint: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn displayable_fingerprint_local(
        displayable: *const displayable_fingerprint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn displayable_fingerprint_remote(
        displayable: *const displayable_fingerprint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn displayable_fingerprint_text(
        displayable: *const displayable_fingerprint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn displayable_fingerprint_destroy(type_: *mut signal_type_base);
}
extern "C" {
    pub fn scannable_fingerprint_create(
        scannable: *mut *mut scannable_fingerprint,
        version: u32,
        local_stable_identifier: *const ::std::os::raw::c_char,
        local_fingerprint: *const signal_buffer,
        remote_stable_identifier: *const ::std::os::raw::c_char,
        remote_fingerprint: *const signal_buffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scannable_fingerprint_serialize(
        buffer: *mut *mut signal_buffer,
        scannable: *const scannable_fingerprint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scannable_fingerprint_deserialize(
        scannable: *mut *mut scannable_fingerprint,
        data: *const u8,
        len: usize,
        global_context: *mut signal_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scannable_fingerprint_get_version(
        scannable: *const scannable_fingerprint,
    ) -> u32;
}
extern "C" {
    pub fn scannable_fingerprint_get_local_stable_identifier(
        scannable: *const scannable_fingerprint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn scannable_fingerprint_get_local_fingerprint(
        scannable: *const scannable_fingerprint,
    ) -> *mut signal_buffer;
}
extern "C" {
    pub fn scannable_fingerprint_get_remote_stable_identifier(
        scannable: *const scannable_fingerprint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn scannable_fingerprint_get_remote_fingerprint(
        scannable: *const scannable_fingerprint,
    ) -> *mut signal_buffer;
}
extern "C" {
    /// Compare a scanned QR code with what we expect.
    /// @param scannable The local scannable data
    /// @param other_scannable The data from the scanned code
    /// @retval 1 if the scannable codes match
    /// @retval 0 if the scannable codes do not match
    /// @retval SG_ERR_FP_VERSION_MISMATCH if the scanned fingerprint is the
    /// wrong version
    /// @retval SG_ERR_FP_IDENT_MISMATCH if the scanned fingerprint is for the
    /// wrong stable identifier
    pub fn scannable_fingerprint_compare(
        scannable: *const scannable_fingerprint,
        other_scannable: *const scannable_fingerprint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scannable_fingerprint_destroy(type_: *mut signal_type_base);
}
